---
title: "Project1"
format: html
editor: visual
---

## Data Processing

```{r}
library(httr)
library(jsonlite)
library(dplyr)
library(tidyverse)
library(lubridate)
```

Using PUMS data from the Census API, we are going to complete the data processing part of Project 1. First we will read in the data, then create some functions to query the API and return a tibble. The following code chunk is reading in the data, then checking the structure so we can figure out how to turn it into a tibble.

```{r}
pums_URL <- "https://api.census.gov/data/2022/acs/acs1/pums?get=SEX,PWGTP,MAR&SCHL=24"
pums_data <- httr::GET(pums_URL)
str(pums_data)
```

Next, we need to write a helper function that can take the output of GET() and turn it into a tibble. The function, clean_census(), was written generally, so it can be used to turn any Census API query response into a tibble, which keeps the code reusable. Then, we plugged in some PUMS data to see how it returns a sample tibble.

```{r}
clean_census <- function(res) {
  pums_parsed <- fromJSON(rawToChar(res$content))
  colnames(pums_parsed) <- pums_parsed[1,]
  pums_info <- as_tibble(pums_parsed[-1,])
  return(pums_info)
}
pums_info <- clean_census(pums_data)
pums_info
```

This code chunk contains some setup for the next function. 

```{r}
jwap_url <- "https://api.census.gov/data/2022/acs/acs1/pums/variables/JWAP.json"
jwap_blob <- fromJSON(jwap_url)
jwap_lookup <- jwap_blob$values$item
names(jwap_lookup) <- as.numeric(names(jwap_lookup))

jwdp_url <- "https://api.census.gov/data/2022/acs/acs1/pums/variables/JWDP.json"
jwdp_blob <- fromJSON(url)
jwdp_lookup <- jwdp_blob$values$item
names(jwdp_lookup) <- as.numeric(names(jwdp_lookup))

FER_labels <- c("0" = "N/A (less than 15 years/greater than 50 years/ male)", "1" = "Yes", "2" = "No")

HHL_labels <- c("0" = "N/A (GQ/vacant)", "1" = "English Only", "2" = "Spanish", "3" = "Other Indo-European languages", "4" = "Asian and Pacific Island languages", "5" = "Other Language")

HISPEED_labels <- c("0" = "N/A (GQ/vacant/no paid access to the internet)", "1" = "Yes", "2" = "No")

JWTRNS_labels <- c("0" = "N/A (not a worker-not in the labor force, including persons under 16 years; unemployed; employed, with a job but not at work; Armed Forces, with a job but not at work)", "1" = "Car, truck, or van", "2" = "Bus", "3" = "Subway or elevated rail", "4" = "Long-distance train or commuter rail", "5" = "Light rail, streetcar, or trolley", "6" = "Ferryboat", "7" = "Taxicab", "8" = "Motorcycle", "9" = "Bicycle", "10" = "Walked", "11" = "Worked from home", "12" = "Other method")

SCH_labels <- c("0" = "N/A (less than 3 years old)", "1" = "No, has not attended in the last 3 months", "2" = "Yes, public school or public college", "3" = "Yes, private school or college or home school")

SCHL_labels <- c("0" = "N/A (less than 3 years old)", "1" = "No schooling completed", "2" = "Nursery school, preschool", "3" = "Kindergarten", "4" = "Grade 1", "5" = "Grade 2", "6" = "Grade 3", "7" = "Grade 4", "8" = "Grade 5", "9" = "Grade 6", "10" = "Grade 7", "11" = "Grade 8", "12" = "Grade 9", "13" = "Grade 10", "14" = "Grade 11", "15" = "12th grade - no diploma", "16" = "Regular high school diploma", "17" = "GED or alternative credential", "18" = "Some college, but less than 1 year", "19" = "1 or more years of college credit, no degree", "20" = "Associate's degree", "21" = "Bachelor's degree", "22" = "Master's degree", "23" = "Professional degree beyond a bachelor's degree", "24" = "Doctorate degree")

SEX_labels <- c("1" = "Male", "2" = "Female")

label_mappings <- list(
  "FER" = FER_labels, "HHL" = HHL_labels, "HISPEED" = HISPEED_labels, "JWTRNS" = JWTRNS_labels, "SCH" = SCH_labels, "SCHL" = SCHL_labels, "SEX" = SEX_labels
)
```

Now, we need a function that can query the API and allow the user to change a few things. To do this, we wrote a function that requires that the year be between 2010 and 2022, includes at least one variable other than PWGTP, specifies categorical variables to be returned, specifies geography level, and allows for optional subsetting of the data. Our function, pums_query(), checks that the inputs are valid which helps to avoid API errors. We used state '37' instead of our assigned state '03' because that state code was invalid.

```{r}
pums_query <- function(year = 2022, numeric_variables = c("AGEP", "PWGTP"), categorical_variables = c("SEX"), geography = "state", state = "37", filter = NULL){
  if(!(year %in% 2010:2022)){
    stop("Year is not valid")
  }
  if(!("PWGTP" %in% numeric_variables)){
    stop("PWGTP must be in numeric_variables")
  }
  if(length(numeric_variables) < 2){
    stop("Another numeric variable must be requested")
  }
  if(length(categorical_variables) < 1){
    stop("A categorical variable must be requested")
  }
  if(!(tolower(geography) %in% c("all", "region", "division", "state"))){
    stop("Must specify geography level")
  }
  if(!(state %in% sprintf("%02d", 1:72))){
    stop("State must be 2 digit code between 01 and 56")
  }
  variables <- paste(c(numeric_variables, categorical_variables, "ST"), collapse = ",")
  build_url <- paste0("https://api.census.gov/data/", year, "/acs/acs1/pums?get=", variables)
  
  url_result <- httr::GET(build_url)
  if(status_code(url_result) != 200){
    stop("Request failed with status: ", status_code(url_result))
  }
  
  census_tibble <- fromJSON(rawToChar(url_result$content))
  colnames(census_tibble) <- census_tibble[1,]
  census_tibble <- as_tibble(census_tibble[-1,])
  census_tibble <- census_tibble[census_tibble$ST == state,]
  
  numeric_options <- c("AGEP", "GASP", "GRPIP", "PWGTP", "JWMNP")
  numeric_values <- intersect(numeric_options, numeric_variables)
  census_tibble[numeric_values] <- lapply(census_tibble[numeric_values], as.numeric)
  
  time_options <- c("JWAP", "JWDP")
  time_values <- intersect(time_options, numeric_variables)
  
  time_convert <- function(date_range){
    if (startsWith(date_range, "N")) return(NA)
    times <- strsplit(date_range, " to ")[[1]]
    start_time <- period_to_seconds(hm(times[1]))
    end_time <- period_to_seconds(hm(times[2]))
    if (end_time < start_time) end_time <- end_time + 24*3600
    seconds <- (start_time + end_time) / 2
    time <- as.POSIXct(seconds, origin = "1970-01-01", tz = "UTC")
    return(format(time, "%H:%M:%S %p"))
  }
  
  if ("JWAP" %in% names(census_tibble)){
    census_tibble[["JWAP"]] <- sapply(census_tibble[["JWAP"]], function(x) time_convert(jwap_lookup[[x]]))
  }
  if ("JWDP" %in% names(census_tibble)){
    census_tibble[["JWDP"]] <- sapply(census_tibble[["JWDP"]], function(x) time_convert(jwdp_lookup[[x]]))
  }
  
  if ("FER" %in% names(census_tibble)){
    census_tibble[["FER"]] <- factor(census_tibble[["FER"]], levels = names(FER_labels), labels = FER_labels)
  }
  if ("HHL" %in% names(census_tibble)){
    census_tibble[["HHL"]] <- factor(census_tibble[["HHL"]], levels = names(HHL_labels), labels = HHL_labels)
  }
  if ("HISPEED" %in% names(census_tibble)){
    census_tibble[["HISPEED"]] <- factor(census_tibble[["HISPEED"]], levels = names(HISPEED_labels), labels = HISPEED_labels)
  }
  if ("JWTRNS" %in% names(census_tibble)){
    census_tibble[["JWTRNS"]] <- factor(census_tibble[["JWTRNS"]], levels = names(JWTRNS_labels), labels = JWTRNS_labels)
  }
  if ("SCH" %in% names(census_tibble)){
    census_tibble[["SCH"]] <- factor(census_tibble[["SCH"]], levels = names(SCH_labels), labels = SCH_labels)
  }
  if ("SCHL" %in% names(census_tibble)){
    census_tibble[["SCHL"]] <- factor(census_tibble[["SCHL"]], levels = names(SCHL_labels), labels = SCHL_labels)
  }
  if ("SEX" %in% names(census_tibble)){
    census_tibble[["SEX"]] <- factor(census_tibble[["SEX"]], levels = names(SEX_labels), labels = SEX_labels)
  }
  
  return(census_tibble)
}
```


```{r}
pums_query(numeric_variables = c("JWAP", "PWGTP"), categorical_variables = c("SEX"))
```


Now, we need to call the function to create a tibble to work with in the next section. 

```{r}
sample_data <- pums_query(
  year = 2022, numeric_variables = c("AGEP", "PWGTP", "GASP", "GRPIP", "JWAP", "JWDP", "JWMNP"), categorical_variables = c("SEX", "FER", "HHL", "HISPEED", "JWTRNS", "SCH", "SCHL"), state = "37"
)
head(sample_data)
```

The last function was able to return a tibble for a single year of data, but now we are going to make a multiyear function. Pums_multi_year() loops over each requested year, calls pums_query() for each, and combines the results into a single tibble with a year column. This allows for comparison across years.

```{r}
pums_multi_year <- function(years = 2022, numeric_variables = c("AGEP", "PWGTP"), categorical_variables = c("SEX"), geography = "state", state = "37", filter = NULL){
  years <- as.integer(years)
  all_data <- list()
  for(yr in years){
    test_tibble <- pums_query(
      year = yr, numeric_variables = numeric_variables, categorical_variables = categorical_variables, geography = geography, state = state, filter = filter
    )
    test_tibble$year <- yr
    all_data[[as.character(yr)]] <- test_tibble
  }
  combined_data <- dplyr::bind_rows(all_data)
  return(combined_data)
}
```

Now, we need to call the function to create a tibble to work with in the next section. 

```{r}
sample_data <- pums_query(
  year = 2022, numeric_variables = c("AGEP", "PWGTP", "GASP", "GRPIP", "JWAP", "JWDP", "JWMNP"), categorical_variables = c("SEX", "FER", "HHL", "HISPEED", "JWTRNS", "SCH", "SCHL"), state = "37"
)
# Convert numerics to double and categoricals to character
sample_data <- sample_data |>
  mutate(across(c(AGEP, PWGTP, GASP, GRPIP, JWAP, JWDP, JWMNP), as.double),
         across(c(SEX, FER, HHL, HISPEED, SCH, SCHL), as.character))

head(sample_data)
```

Now to test the multi-year function.

```{r}
sample_multi_year <- pums_multi_year(
  years = 2018:2019, numeric_variables = c("AGEP", "PWGTP", "GASP", "GRPIP", "JWAP", "JWDP", "JWMNP"), categorical_variables = c("SEX", "FER", "HHL", "HISPEED", "SCH", "SCHL"), state = "37"
)
head(sample_multi_year)

# Convert numerics to double and categoricals to character
sample_multi_year <- sample_multi_year |>
  mutate(across(c(AGEP, PWGTP, GASP, GRPIP, JWAP, JWDP, JWMNP), as.double),
         across(c(SEX, FER, HHL, HISPEED, SCH, SCHL), as.character))
```




#Writing a Generic Function for Summarizing and Plotting

Here we write a general function for summarizing. This function takes in three arguments: the tibble with class census, the numeric variable(s) to summarize, and the categorical variable(s) to summarize. By default, this function summarizes all numeric variables (other than PWGTP) and all categorical variables
in the tibble. However, the user may also specify the variables they’d like to summarize. For numerical variables, the function will give the sample mean and standard deviation, and for categorigal variables the function returns the counts. Here we also write a general function for plotting, where the user to specify one categorical variable and one numeric variable for plotting purposes.

```{r}
library(dplyr)
#check structure of tibble
str(sample_data)

#Run these in your console
plot.function #what is used for a class = function
getS3method("plot","data.frame") #what is used for a class = data frame
plot
#Add our own class to our census data for summarizing purposes.
class(sample_data) <- c("census", class(sample_data))

summary.census <- function(census, numeric_var=NULL, car_var=NULL){
  # assigning weight to the column PWGTP in the data
  weight <- census$PWGTP
  
  if (is.null(numeric_var) & is.null(car_var)) {
   numeric_cols <- names(census)[sapply(census, is.numeric)]

summary <- census |>
  reframe(
    # Sample mean
    across(
      all_of(numeric_cols),
      function(x) sum(x * weight / sum(weight)),
      .names = "{.col}_sample_mean"
    ),
    # Sample standard deviation
    across(
      all_of(numeric_cols),
      function(x) sqrt(sum(x^2 * weight) / sum(weight) - (sum(x * weight / sum(weight)))^2),
      .names = "{.col}_sample_sd"
    )
  )
   cat_counts <- census |>
      pivot_longer(
        cols = where(is.character),
        names_to = "variable",
        values_to = "value"
      ) |>
      group_by(variable, value) |>
      summarise(weighted_count = sum(PWGTP), .groups = "drop")

return(list(
  Numeric_Summary = summary,
  Categorical_Counts = cat_counts
))

  } else if (is.null(numeric_var)) { 
   cat_counts <- car_var |>
      pivot_longer(
        cols = where(is.character),
        names_to = "variable",
        values_to = "value"
      ) |>
      group_by(variable, value) |>
      summarise(weighted_count = sum(PWGTP), .groups = "drop")
    
  } else if(is.null(car_var)) {
  
  #need to find the sample mean and standard deviation for the numerical variables they provided
    
    summary <- census |>
  reframe(
    # Sample mean
    across(
      all_of(numeric_var),
      function(x) sum(x * weight / sum(weight)),
      .names = "{.col}_sample_mean"
    ),
    # Sample standard deviation
    across(
      all_of(numeric_var),
      function(x) sqrt(sum(x^2 * weight) / sum(weight) - (sum(x * weight / sum(weight)))^2),
      .names = "{.col}_sample_sd"
    )
  )
return(list(
  Numeric_Summary = summary
))

  }else{
  return("Try input again.")
  }
    
    
} 
#Test of just entering tibble
summary.census(sample_data)
#Test of entering tibble with numeric variable
summary.census(sample_data, numeric_var = "AGEP")
#Test of entering tibble with categorical variable
summary.census(sample_data, cat_var = "SEX")
  #Test of entering tibble with categorical variable
summary.census(sample_data, numeric_var = "AGEP", cat_var = "SEX")


#summarize_census(census, c(income, age), c(gender, education))

```
