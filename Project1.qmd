---
title: "Project1"
format: html
editor: visual
---

## Data Processing

```{r}
library(httr)
library(jsonlite)
library(dplyr)
library(tidyverse)
library(lubridate)
```

Using PUMS data from the Census API, we are going to complete the data processing part of Project 1. First we will read in the data, then create some functions to query the API and return a tibble. The following code chunk is reading in the data, then checking the structure so we can figure out how to turn it into a tibble.

```{r}
pums_URL <- "https://api.census.gov/data/2022/acs/acs1/pums?get=SEX,PWGTP,MAR&SCHL=24"
pums_data <- httr::GET(pums_URL)
str(pums_data)
```

Next, we need to write a helper function that can take the output of GET() and turn it into a tibble. The function, clean_census(), was written generally, so it can be used to turn any Census API query response into a tibble, which keeps the code reusable. Then, we plugged in some PUMS data to see how it returns a sample tibble.

```{r}
clean_census <- function(res) {
  pums_parsed <- fromJSON(rawToChar(res$content))
  colnames(pums_parsed) <- pums_parsed[1,]
  pums_info <- as_tibble(pums_parsed[-1,])
  return(pums_info)
}
pums_info <- clean_census(pums_data)
pums_info
```

This code chunk contains some setup for the next function. 

```{r}
jwap_url <- "https://api.census.gov/data/2022/acs/acs1/pums/variables/JWAP.json"
jwap_blob <- fromJSON(jwap_url)
jwap_lookup <- jwap_blob$values$item
names(jwap_lookup) <- as.numeric(names(jwap_lookup))

jwdp_url <- "https://api.census.gov/data/2022/acs/acs1/pums/variables/JWDP.json"
jwdp_blob <- fromJSON(url)
jwdp_lookup <- jwdp_blob$values$item
names(jwdp_lookup) <- as.numeric(names(jwdp_lookup))

FER_labels <- c("0" = "N/A (less than 15 years/greater than 50 years/ male)", "1" = "Yes", "2" = "No")

HHL_labels <- c("0" = "N/A (GQ/vacant)", "1" = "English Only", "2" = "Spanish", "3" = "Other Indo-European languages", "4" = "Asian and Pacific Island languages", "5" = "Other Language")

HISPEED_labels <- c("0" = "N/A (GQ/vacant/no paid access to the internet)", "1" = "Yes", "2" = "No")

JWTRNS_labels <- c("0" = "N/A (not a worker-not in the labor force, including persons under 16 years; unemployed; employed, with a job but not at work; Armed Forces, with a job but not at work)", "1" = "Car, truck, or van", "2" = "Bus", "3" = "Subway or elevated rail", "4" = "Long-distance train or commuter rail", "5" = "Light rail, streetcar, or trolley", "6" = "Ferryboat", "7" = "Taxicab", "8" = "Motorcycle", "9" = "Bicycle", "10" = "Walked", "11" = "Worked from home", "12" = "Other method")

SCH_labels <- c("0" = "N/A (less than 3 years old)", "1" = "No, has not attended in the last 3 months", "2" = "Yes, public school or public college", "3" = "Yes, private school or college or home school")

SCHL_labels <- c("0" = "N/A (less than 3 years old)", "1" = "No schooling completed", "2" = "Nursery school, preschool", "3" = "Kindergarten", "4" = "Grade 1", "5" = "Grade 2", "6" = "Grade 3", "7" = "Grade 4", "8" = "Grade 5", "9" = "Grade 6", "10" = "Grade 7", "11" = "Grade 8", "12" = "Grade 9", "13" = "Grade 10", "14" = "Grade 11", "15" = "12th grade - no diploma", "16" = "Regular high school diploma", "17" = "GED or alternative credential", "18" = "Some college, but less than 1 year", "19" = "1 or more years of college credit, no degree", "20" = "Associate's degree", "21" = "Bachelor's degree", "22" = "Master's degree", "23" = "Professional degree beyond a bachelor's degree", "24" = "Doctorate degree")

SEX_labels <- c("1" = "Male", "2" = "Female")

label_mappings <- list(
  "FER" = FER_labels, "HHL" = HHL_labels, "HISPEED" = HISPEED_labels, "JWTRNS" = JWTRNS_labels, "SCH" = SCH_labels, "SCHL" = SCHL_labels, "SEX" = SEX_labels
)
```

Now, we need a function that can query the API and allow the user to change a few things. To do this, we wrote a function that requires that the year be between 2010 and 2022, includes at least one variable other than PWGTP, specifies categorical variables to be returned, specifies geography level, and allows for optional subsetting of the data. Our function, pums_query(), checks that the inputs are valid which helps to avoid API errors. We used state '37' instead of our assigned state '03' because that state code was invalid.

```{r}
pums_query <- function(year = 2022, numeric_variables = c("AGEP", "PWGTP"), categorical_variables = c("SEX"), geography = "state", state = "37", filter = NULL){
  if(!(year %in% 2010:2022)){
    stop("Year is not valid")
  }
  if(!("PWGTP" %in% numeric_variables)){
    stop("PWGTP must be in numeric_variables")
  }
  if(length(numeric_variables) < 2){
    stop("Another numeric variable must be requested")
  }
  if(length(categorical_variables) < 1){
    stop("A categorical variable must be requested")
  }
  if(!(tolower(geography) %in% c("all", "region", "division", "state"))){
    stop("Must specify geography level")
  }
  if(!(state %in% sprintf("%02d", 1:72))){
    stop("State must be 2 digit code between 01 and 56")
  }
  variables <- paste(c(numeric_variables, categorical_variables, "ST"), collapse = ",")
  build_url <- paste0("https://api.census.gov/data/", year, "/acs/acs1/pums?get=", variables)
  
  url_result <- httr::GET(build_url)
  if(status_code(url_result) != 200){
    stop("Request failed with status: ", status_code(url_result))
  }
  
  census_tibble <- fromJSON(rawToChar(url_result$content))
  colnames(census_tibble) <- census_tibble[1,]
  census_tibble <- as_tibble(census_tibble[-1,])
  census_tibble <- census_tibble[census_tibble$ST == state,]
  
  numeric_options <- c("AGEP", "GASP", "GRPIP", "PWGTP", "JWMNP")
  numeric_values <- intersect(numeric_options, numeric_variables)
  census_tibble[numeric_values] <- lapply(census_tibble[numeric_values], as.numeric)
  
  time_options <- c("JWAP", "JWDP")
  time_values <- intersect(time_options, numeric_variables)
  
  time_convert <- function(date_range){
    if (startsWith(date_range, "N")) return(NA)
    times <- strsplit(date_range, " to ")[[1]]
    start_time <- period_to_seconds(hm(times[1]))
    end_time <- period_to_seconds(hm(times[2]))
    if (end_time < start_time) end_time <- end_time + 24*3600
    seconds <- (start_time + end_time) / 2
    time <- as.POSIXct(seconds, origin = "1970-01-01", tz = "UTC")
    return(format(time, "%H:%M:%S %p"))
  }
  
  if ("JWAP" %in% names(census_tibble)){
    census_tibble[["JWAP"]] <- sapply(census_tibble[["JWAP"]], function(x) time_convert(jwap_lookup[[x]]))
  }
  if ("JWDP" %in% names(census_tibble)){
    census_tibble[["JWDP"]] <- sapply(census_tibble[["JWDP"]], function(x) time_convert(jwdp_lookup[[x]]))
  }
  
  if ("FER" %in% names(census_tibble)){
    census_tibble[["FER"]] <- factor(census_tibble[["FER"]], levels = names(FER_labels), labels = FER_labels)
  }
  if ("HHL" %in% names(census_tibble)){
    census_tibble[["HHL"]] <- factor(census_tibble[["HHL"]], levels = names(HHL_labels), labels = HHL_labels)
  }
  if ("HISPEED" %in% names(census_tibble)){
    census_tibble[["HISPEED"]] <- factor(census_tibble[["HISPEED"]], levels = names(HISPEED_labels), labels = HISPEED_labels)
  }
  if ("JWTRNS" %in% names(census_tibble)){
    census_tibble[["JWTRNS"]] <- factor(census_tibble[["JWTRNS"]], levels = names(JWTRNS_labels), labels = JWTRNS_labels)
  }
  if ("SCH" %in% names(census_tibble)){
    census_tibble[["SCH"]] <- factor(census_tibble[["SCH"]], levels = names(SCH_labels), labels = SCH_labels)
  }
  if ("SCHL" %in% names(census_tibble)){
    census_tibble[["SCHL"]] <- factor(census_tibble[["SCHL"]], levels = names(SCHL_labels), labels = SCHL_labels)
  }
  if ("SEX" %in% names(census_tibble)){
    census_tibble[["SEX"]] <- factor(census_tibble[["SEX"]], levels = names(SEX_labels), labels = SEX_labels)
  }
  
  return(census_tibble)
}
```

Now, we need to call the function to create a tibble to work with in the next section. 

```{r}
sample_data <- pums_query(
  year = 2022, numeric_variables = c("AGEP", "PWGTP", "GASP", "GRPIP", "JWAP", "JWDP", "JWMNP"), categorical_variables = c("SEX", "FER", "HHL", "HISPEED", "JWTRNS", "SCH", "SCHL"), state = "37"
)
head(sample_data)
```

The last function was able to return a tibble for a single year of data, but now we are going to make a multiyear function. Pums_multi_year() loops over each requested year, calls pums_query() for each, and combines the results into a single tibble with a year column. This allows for comparison across years.

```{r}
pums_multi_year <- function(years = 2022, numeric_variables = c("AGEP", "PWGTP"), categorical_variables = c("SEX"), geography = "state", state = "37", filter = NULL){
  years <- as.integer(years)
  all_data <- list()
  for(yr in years){
    test_tibble <- pums_query(
      year = yr, numeric_variables = numeric_variables, categorical_variables = categorical_variables, geography = geography, state = state, filter = filter
    )
    test_tibble$year <- yr
    all_data[[as.character(yr)]] <- test_tibble
  }
  combined_data <- dplyr::bind_rows(all_data)
  return(combined_data)
}
```

Now to test the multi-year function.

```{r}
sample_multi_year <- pums_multi_year(
  years = 2018:2019, numeric_variables = c("AGEP", "PWGTP", "GASP", "GRPIP", "JWAP", "JWDP", "JWMNP"), categorical_variables = c("SEX", "FER", "HHL", "HISPEED", "SCH", "SCHL"), state = "37"
)
head(sample_multi_year)
```
#Writing a Generic Function for Summarizing

```{r}
library(dplyr)
#Run these in your console
plot.function #what is used for a class = function
getS3method("plot","data.frame") #what is used for a class = data frame
plot
#Add our own class to our census data for summarizing purposes.
class(census_tibble) <- c("census", class(census_tibble))
#check structure of tibble
str(census_tibble)
summary.census <- function(census, numeric_var=NULL, car_var=NULL){
#assigning weight to the column PWGTP in the data
  weight <- census$PWGTP
 if (is.null(numeric_var) & is.null(car_var)) {
   summary<-census |>
     # Sample mean for numeric variables
        across(
          where(is.numeric),
          function(x){
            s_mean <- sum(x * weight / sum(weight))
            return(s_mean)
          },
          .names="{.col}_sample_mean"
        )
        # Sample standard deviation for numeric variables
        across(
          where(is.numeric),
          function(x){
            s_mean <- sum(x * weight / sum(weight))   # recompute mean here
            s_sd <- sqrt(sum(x^2 * weight)/sum(weight) - s_mean^2)
            return(s_sd)
        }
        ,.names="{.col}_sample_sd"
     )
   across(
       where(is.character),
        function(x){
              #Count
           return(setNames(as.vector(table(x)), names(table(x)))) 
        }
       ,.names = "{.col}_counts" 
   )
   

   return(list(
      Numeric_Summary = summary,
      Sex_Counts = summary$SEX_counts[[1]],
      Mar_Counts = summary$MAR_counts[[1]],
      SCHL_Counts = summary$SCHL_counts[[1]]
    ))
   }else{
    stop("cat_var is NULL")
  }
}
summary.census(census_tibble)
# numeric summaries
 
# categorical summaries
  


#summarize_census(census, c(income, age), c(gender, education))

```
