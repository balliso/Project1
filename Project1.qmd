---
title: "Project1"
author: "Bailey Allison & Laurie Short"
date: "2025-10-01"
output: html_document
purpose: "Project using Census data to query, summarize, and visualize trends."
editor: visual
---
# Introduction

For this project, we are working with the Census Public Use Microdata Sample API. This PUMS data
Our goal is to write a function to query this API to return a nicely formatted tibble, and then write a summary function to summarize and visualize the data. After creating and testing our functions, we used them to investigate how JWAP and JWDP evolve over time by plotting the averages for each year.

# Data Processing

In this section, we process data from the Census PUMS API. The goal is to build a set of functions that return clean tibbles that are easy to work with in R. We will explore the raw API response and create helper functions to clean and structure the data. Then, we modify the functions so a user can customize which variables and years are returned.

```{r}
library(httr)
library(jsonlite)
library(dplyr)
library(tidyverse)
library(lubridate)
library(ggplot2) 
```

The following code chunk reads in the data and checks the structure so we can figure out how to turn it into a tibble.

```{r}
pums_URL <- "https://api.census.gov/data/2022/acs/acs1/pums?get=SEX,PWGTP,MAR&SCHL=24"
pums_data <- httr::GET(pums_URL)
str(pums_data)
```

The raw output from httr::GET() is not immediately usable because it comes as JSON text with column names embedded in the first row. To fix this, we wrote a helper function called clean_census(). This function extracts the column names, removes the header row, and returns the result as a tibble. Because it is written generally, it can be reused for any Census API response.

```{r}
clean_query_result <- function(res) {
  pums_parsed <- fromJSON(rawToChar(res$content))
  colnames(pums_parsed) <- pums_parsed[1,]
  pums_info <- as_tibble(pums_parsed[-1,])
  return(pums_info)
}
```

This code chunk creates some look up tables that will be useful for turning numeric variables into time values later in the pums_query() function. 

```{r}
# Query the API for a table describing the JWAP and JWDP categorical variables and then create lookup tables to turn numeric variables into time variables later

jwap_url <- "https://api.census.gov/data/2022/acs/acs1/pums/variables/JWAP.json"
jwap_blob <- fromJSON(jwap_url)
jwap_lookup <- jwap_blob$values$item
names(jwap_lookup) <- as.numeric(names(jwap_lookup))

jwdp_url <- "https://api.census.gov/data/2022/acs/acs1/pums/variables/JWDP.json"
jwdp_blob <- fromJSON(jwdp_url)
jwdp_lookup <- jwdp_blob$values$item
names(jwdp_lookup) <- as.numeric(names(jwdp_lookup))
```

This code chunk creates some lists that will be useful for turning categorical variables into factors with appropriate levels later in the pums_query() function. 

```{r}
# Save categorical variables as lists to turn into a factor with appropriate levels later

FER_labels <- c("0" = "N/A (less than 15 years/greater than 50 years/ male)", "1" = "Yes", "2" = "No")

HHL_labels <- c("0" = "N/A (GQ/vacant)", "1" = "English Only", "2" = "Spanish", "3" = "Other Indo-European languages", "4" = "Asian and Pacific Island languages", "5" = "Other Language")

HISPEED_labels <- c("0" = "N/A (GQ/vacant/no paid access to the internet)", "1" = "Yes", "2" = "No")

JWTRNS_labels <- c("0" = "N/A (not a worker-not in the labor force, including persons under 16 years; unemployed; employed, with a job but not at work; Armed Forces, with a job but not at work)", "1" = "Car, truck, or van", "2" = "Bus", "3" = "Subway or elevated rail", "4" = "Long-distance train or commuter rail", "5" = "Light rail, streetcar, or trolley", "6" = "Ferryboat", "7" = "Taxicab", "8" = "Motorcycle", "9" = "Bicycle", "10" = "Walked", "11" = "Worked from home", "12" = "Other method")

SCH_labels <- c("0" = "N/A (less than 3 years old)", "1" = "No, has not attended in the last 3 months", "2" = "Yes, public school or public college", "3" = "Yes, private school or college or home school")

SCHL_labels <- c("0" = "N/A (less than 3 years old)", "1" = "No schooling completed", "2" = "Nursery school, preschool", "3" = "Kindergarten", "4" = "Grade 1", "5" = "Grade 2", "6" = "Grade 3", "7" = "Grade 4", "8" = "Grade 5", "9" = "Grade 6", "10" = "Grade 7", "11" = "Grade 8", "12" = "Grade 9", "13" = "Grade 10", "14" = "Grade 11", "15" = "12th grade - no diploma", "16" = "Regular high school diploma", "17" = "GED or alternative credential", "18" = "Some college, but less than 1 year", "19" = "1 or more years of college credit, no degree", "20" = "Associate's degree", "21" = "Bachelor's degree", "22" = "Master's degree", "23" = "Professional degree beyond a bachelor's degree", "24" = "Doctorate degree")

SEX_labels <- c("1" = "Male", "2" = "Female")
```

Now, we need a function that can query the API and allow the user to change a few things. To do this, we wrote a function that requires that the year be between 2010 and 2022, includes at least one variable other than PWGTP, specifies categorical variables to be returned, specifies geography level, and allows for optional subsetting of the data. Our function, pums_query(), checks that the inputs are valid which helps to avoid API errors. We used state '37' instead of our assigned state '03' because that state code was invalid.

```{r}
# Query the API; we used state code 37 because 03 was invalid
pums_query <- function(year = 2022, numeric_variables = c("AGEP", "PWGTP"), categorical_variables = c("SEX"), geography = "state", geography_code = "37"){
  
# Argument error checking
  if(!(year %in% 2010:2022)){
    stop("Year is not valid")
  }
  if(!("PWGTP" %in% numeric_variables)){
    stop("PWGTP must be in numeric_variables")
  }
  if(length(numeric_variables) < 2){
    stop("Another numeric variable must be requested")
  }
  if(length(categorical_variables) < 1){
    stop("A categorical variable must be requested")
  }
  if(!(tolower(geography) %in% c("all", "region", "division", "state"))){
    stop("Must specify geography level")
  }
  if(geography == "state" && (!(geography_code %in% sprintf("%02d", 1:72)) && geography_code != "*")){
    stop("Geography_code for state must be 2 digit code between 01 and 72 or = * for all states")
  }
  if(geography == "region" && (!(geography_code %in% sprintf("%01d", 1:4)) && geography_code != "*")){
    stop("Geography_code for region must be code between 1 and 4 or = * for all regions")
  }
  if(geography == "division" && (!(geography_code %in% sprintf("%01d", 1:9)) && geography_code != "*")){
    stop("Geography_code for division must be code between 1 and 9 or = * for all divisions")
  }
  
# Combine variables into a comma separated string
  variables <- paste(c(numeric_variables, categorical_variables), collapse = ",")
  
# Create the geography part of the query, allowing for subsetting. This code allows for user to call "all" geography by not including geography key from the URL if "all" is called.
  geography_key <- ""
  if (geography != "all"){
    geography_key <- paste0("&for=", geography,":", geography_code)
  }
  
# Build the URL from the provided arguments
  build_url <- paste0("https://api.census.gov/data/", year, "/acs/acs1/pums?get=", variables, geography_key)
  
# Send http GET request
  url_result <- httr::GET(build_url)
  if(status_code(url_result) != 200){
    stop("Request failed with status: ", status_code(url_result))
  }
  
# Use helper function to turn url_result into a tibble
  census_tibble <- clean_query_result(url_result)
  
# Turn numeric variables into numeric values
  numeric_options <- c("AGEP", "GASP", "GRPIP", "PWGTP", "JWMNP")
  numeric_values <- intersect(numeric_options, numeric_variables)
  census_tibble[numeric_values] <- lapply(census_tibble[numeric_values], as.numeric)
  
# Helper function which converts a given time range string into a time string which is the midpoint of the range
  time_convert <- function(time_range){
    if (startsWith(time_range, "N")) return(NA)
    times <- strsplit(time_range, " to ")[[1]]
    start_time <- period_to_seconds(hm(times[1]))
    end_time <- period_to_seconds(hm(times[2]))
    if (end_time < start_time) end_time <- end_time + 24*3600
    seconds <- (start_time + end_time) / 2
    time <- as.POSIXct(seconds, origin = "1970-01-01", tz = "UTC")
    return(format(time, "%H:%M:%S %p"))
  }
# Convert all values in JWAP and JWDP into time
  if ("JWAP" %in% names(census_tibble)){
    census_tibble[["JWAP"]] <- sapply(census_tibble[["JWAP"]], function(x) time_convert(jwap_lookup[[x]]))
  }
  if ("JWDP" %in% names(census_tibble)){
    census_tibble[["JWDP"]] <- sapply(census_tibble[["JWDP"]], function(x) time_convert(jwdp_lookup[[x]]))
  }
# Convert categorical variable into a factor with appropriate levels 
  if ("FER" %in% names(census_tibble)){
    census_tibble[["FER"]] <- factor(census_tibble[["FER"]], levels = names(FER_labels), labels = FER_labels)
  }
  if ("HHL" %in% names(census_tibble)){
    census_tibble[["HHL"]] <- factor(census_tibble[["HHL"]], levels = names(HHL_labels), labels = HHL_labels)
  }
  if ("HISPEED" %in% names(census_tibble)){
    census_tibble[["HISPEED"]] <- factor(census_tibble[["HISPEED"]], levels = names(HISPEED_labels), labels = HISPEED_labels)
  }
  if ("JWTRNS" %in% names(census_tibble)){
    census_tibble[["JWTRNS"]] <- factor(census_tibble[["JWTRNS"]], levels = names(JWTRNS_labels), labels = JWTRNS_labels)
  }
  if ("SCH" %in% names(census_tibble)){
    census_tibble[["SCH"]] <- factor(census_tibble[["SCH"]], levels = names(SCH_labels), labels = SCH_labels)
  }
  if ("SCHL" %in% names(census_tibble)){
    census_tibble[["SCHL"]] <- factor(census_tibble[["SCHL"]], levels = names(SCHL_labels), labels = SCHL_labels)
  }
  if ("SEX" %in% names(census_tibble)){
    census_tibble[["SEX"]] <- factor(census_tibble[["SEX"]], levels = names(SEX_labels), labels = SEX_labels)
  }
  
# Add census class to census_tibble
  class(census_tibble) <- c("census", class(census_tibble))
  
  return(census_tibble)
}
```

Now, we can test the data with some different variables.

```{r}
sample_data <- pums_query(
  year = 2022, numeric_variables = c("AGEP", "PWGTP", "GASP", "GRPIP", "JWAP", "JWDP", "JWMNP"), categorical_variables = c("SEX", "FER", "HHL", "HISPEED", "JWTRNS", "SCH", "SCHL"), geography = "state", geography_code = "37"
)
head(sample_data)
```

The last function was able to return a tibble for a single year of data, but now we are going to make a multi-year function. Pums_multi_year() loops over each requested year, calls pums_query() for each, and combines the results into a single tibble with a year column. This allows for comparison across years.

```{r}
# Create a function that calls the single year function as many times as needed and combines into one final tibble
pums_multi_year <- function(years, numeric_variables = c("AGEP", "PWGTP"), categorical_variables = c("SEX"), geography = "state", geography_code = "37"){
  years <- as.integer(years)
  all_data <- list()
# Call single year query function once for each year
  for(yr in years){
    test_tibble <- pums_query(
      year = yr, numeric_variables = numeric_variables, categorical_variables = categorical_variables, geography = geography, geography_code = geography_code
    )
# Add year column
    test_tibble$year <- yr
    
# # Add census class to census_tibble
  class(census_tibble) <- c("census", class(census_tibble))
  
    all_data[[as.character(yr)]] <- test_tibble
  }
# Combines data from given years into one final tibble
  combined_data <- dplyr::bind_rows(all_data)
  return(combined_data)
}
```

Now to test the multi-year function.

```{r}
sample_multi_year <- pums_multi_year(
  years = 2018:2019, numeric_variables = c("AGEP", "PWGTP", "GASP", "GRPIP", "JWAP", "JWDP", "JWMNP"), categorical_variables = c("SEX", "FER", "HHL", "HISPEED", "SCH", "SCHL"), geography = "state", geography_code = "37"
)
head(sample_multi_year)
```


#Writing a Generic Function for Summarizing

Here we write a general function for summarizing. This function takes in three arguments: the tibble with class census, the numeric variable(s) to summarize, and the categorical variable(s) to summarize. By default, this function summarizes all numeric variables (other than PWGTP) and all categorical variables
in the tibble. However, the user may also specify the variables theyâ€™d like to summarize. For numerical variables, the function will give the sample mean and standard deviation, and for categorigal variables the function returns the counts. Here we also write a general function for plotting, where the user to specify one categorical variable and one numeric variable for plotting purposes.

```{r}
#check structure of tibble
str(sample_data)

#Naming all possible categorical variables for the function
all_cat_vars <- c("SEX", "FER", "HHL", "HISPEED", "SCH", "SCHL")

#Naming all possible numerical variables for the funciton
all_num_vars <- c("AGEP", "PWGTP", "GASP", "GRPIP", "JWMNP")

#function takes in tibble, numeric variables, categorical variables
summary_census <- function(census, numeric_var=NULL, cat_var=NULL){
  # assigning weight to the column PWGTP in the data
  weight <- census$PWGTP
  #this first if will give back everything by defalut if no numeric or categorical variables are entered
  if (is.null(numeric_var) & is.null(cat_var)) {
   numeric_cols <- names(census)[sapply(census, is.numeric)]

summary <- census |>
  reframe(
    # Sample mean
    across(
      all_of(c("AGEP", "GASP", "GRPIP", "JWMNP")),
      function(x) sum(x * weight, na.rm = TRUE) / sum(weight, na.rm = TRUE),
      .names = "{.col}_sample_mean"
    ),
    # Sample standard deviation
    across(
      all_of(c("AGEP", "GASP", "GRPIP", "JWMNP")),
      function(x) sqrt(sum((x)^2 * weight, na.rm = TRUE) / sum(weight, na.rm = TRUE) -
         (sum(x * weight, na.rm = TRUE) / sum(weight, na.rm = TRUE))^2),
      .names = "{.col}_sample_sd"
    )
  )
  #here we count the categorical variables
   cat_counts <- census |>
      as.data.frame() |>
     select(c("SEX", "FER", "HHL", "HISPEED", "SCH", "SCHL", "PWGTP")) |>
  pivot_longer(
    cols = c("SEX", "FER", "HHL", "HISPEED", "SCH", "SCHL"),
    names_to = "variable",
    values_to = "value"
  ) |>
      group_by(variable, value) |>
      summarise(weighted_count = sum(PWGTP), .groups = "drop")
#here we return the numerical and categorical summaries
return(list(
  Numeric_Summary = summary,
  Categorical_Counts = cat_counts
))
   
#this handles if the user does not submit any numeric variables, only categorical. It will provide the counts for the categorical variables they provided 
   
  } else if (is.null(numeric_var)) { 
   cat_counts <- census |>
     select(all_cat_vars, PWGTP) |>
      pivot_longer(
       cols = all_of(cat_var),
        names_to = "variable",
        values_to = "value"
      ) |>
      group_by(variable, value) |>
      summarise(weighted_count = sum(PWGTP), .groups = "drop")
   
   return(
  Categorical_Counts = cat_counts
)

#this handles if the user does not submit any categorical variables, only numerical It will provide the summaries for the numerical variables they provided 
  } else if(is.null(cat_var)) {
  
  #need to find the sample mean and standard deviation for the numerical variables they provided
    
    summary <- census |>
  reframe(
    # Sample mean
    across(
      all_of(numeric_var),
      function(x) sum(x * weight / sum(weight)),
      .names = "{.col}_sample_mean"
    ),
    # Sample standard deviation
    across(
      all_of(numeric_var),
      function(x) sqrt(sum(x^2 * weight) / sum(weight) - (sum(x * weight / sum(weight)))^2),
      .names = "{.col}_sample_sd"
    )
  )
return(list(
  Numeric_Summary = summary
))

    #this handles if the user enters categorical and numeric variables
  }else{
  
      cat_counts <- census |>
     select(all_cat_vars, PWGTP) |>
      pivot_longer(
       cols = all_of(cat_var),
        names_to = "variable",
        values_to = "value"
      ) |>
      group_by(variable, value) |>
      summarise(weighted_count = sum(PWGTP), .groups = "drop")
   
      
      #need to find the sample mean and standard deviation for the numerical variables they provided
    
    summary <- census |>
      as.data.frame()|>
  reframe(
    # Sample mean
    across(
      all_of(numeric_var),
      function(x) sum(x * weight / sum(weight)),
      .names = "{.col}_sample_mean"
    ),
    # Sample standard deviation
    across(
      all_of(numeric_var),
      function(x) sqrt(sum(x^2 * weight) / sum(weight) - (sum(x * weight / sum(weight)))^2),
      .names = "{.col}_sample_sd"
    )
  )
      

return(list(
  Numeric_Summary = summary,
  Categorical_Counts = cat_counts
))

    
  }
    
    
} 
#Test of just entering tibble
summary_census(sample_data)

#Test of entering tibble with numeric variable
summary_census(sample_data, numeric_var = "AGEP")

#Test of entering tibble with categorical variable
summary_census(sample_data, cat_var = "SEX")

#Test of entering tibble with categorical variable

summary_census(sample_data, numeric_var = "AGEP", cat_var = "SEX")

#Test of entering tibble with more than one numerical variable

summary_census(sample_data, numeric_var = c("AGEP", "GASP"))

#Test of entering tibble with more than one categorical variable

summary_census(sample_data, cat_var = c("SEX", "SCHL"))

#Test of entering tibble with more than one categorical variable and more than one numeric variable

summary_census(sample_data, numeric_var = c("GRPIP", "JWMNP"), cat_var = c("HHL", "HISPEED"))


```
#Plotting

Here we write a general function for plotting, where the user to specify one categorical variable and one numeric variable for plotting purposes.

```{r}
#Run these in your console
plot.function #what is used for a class = function
getS3method("plot","data.frame") #what is used for a class = data frame
plot

census_plot <-function(census_data, cat_var, num_var){
ggplot(census_data,
aes(x = get(cat_var), y = get(num_var), weight = PWGTP)) +
geom_boxplot()
}

#test of plot function
census_plot(sample_data, cat_var = "SEX", num_var = "AGEP")

```

# Data Investigation

For this investigation, we will investigate if there appears to be a relationship between household internet access and age in North Carolina in 2022. Are young people more likely to have household internet access?

```{r}
# Query API
pums_query(year = 2022, numeric_variables = c("AGEP", "PWGTP"), categorical_variables = "HISPEED", geography = "state", geography_code = "37")

# Summarize
summary_census(sample_data, numeric_var = "AGEP", cat_var ="HISPEED")

# Plot of the variables

census_plot(sample_data, num_var = "AGEP", cat_var = "HISPEED" )



```
Looking at the graph, it does appear that the median age of those that have high speed internet is lower than the median age of those who answered no or N/A. 