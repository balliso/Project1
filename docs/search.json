[
  {
    "objectID": "Project1.html",
    "href": "Project1.html",
    "title": "Project1",
    "section": "",
    "text": "Introduction\nFor this project, we are working with the Census Public Use Microdata Sample (PUMS) API. The PUMS data consists of a sample of individual records from people and housing units across America. Our goal is to write a function to query this API to return a nicely formatted tibble, and then write a summary function to summarize and visualize the data. After creating and testing our functions, we will use them to investigate the relationship between household internet speed and age in North Carolina in 2022. This project demonstrates how functions can streamline API querying and data analysis.\n\n\nData Processing\nIn this section, we process data from the Census PUMS API. The goal is to build a set of functions that return clean tibbles that are easy to work with in R. We explore the raw API response and create helper functions to clean and structure the data. Then, we modify the functions so a user can customize which variables and years are returned.\n\nlibrary(httr)\nlibrary(jsonlite)\nlibrary(dplyr)\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ forcats   1.0.0     ✔ readr     2.1.5\n✔ ggplot2   3.5.2     ✔ stringr   1.5.1\n✔ lubridate 1.9.4     ✔ tibble    3.2.1\n✔ purrr     1.0.4     ✔ tidyr     1.3.1\n\n\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter()  masks stats::filter()\n✖ purrr::flatten() masks jsonlite::flatten()\n✖ dplyr::lag()     masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nlibrary(lubridate)\nlibrary(ggplot2) \n\nThe following code chunk reads in the data and checks the structure so we can figure out how to turn it into a tibble.\n\npums_URL &lt;- \"https://api.census.gov/data/2022/acs/acs1/pums?get=SEX,PWGTP,MAR&SCHL=24\"\npums_data &lt;- httr::GET(pums_URL)\n\n#Check structure\nstr(pums_data)\n\nList of 10\n $ url        : chr \"https://api.census.gov/data/2022/acs/acs1/pums?get=SEX,PWGTP,MAR&SCHL=24\"\n $ status_code: int 200\n $ headers    :List of 12\n  ..$ cache-control               : chr \"max-age=60, must-revalidate\"\n  ..$ access-control-allow-origin : chr \"*\"\n  ..$ access-control-allow-methods: chr \"GET\"\n  ..$ access-control-allow-headers: chr \"Origin, X-Requested-With, Content-Type, Accept\"\n  ..$ referrer-policy             : chr \"same-origin\"\n  ..$ content-security-policy     : chr \"default-src 'self'; img-src 'self' data:; object-src 'none'; script-src 'self' 'unsafe-inline'; style-src 'self\"| __truncated__\n  ..$ x-content-type-options      : chr \"nosniff\"\n  ..$ content-type                : chr \"application/json;charset=utf-8\"\n  ..$ date                        : chr \"Thu, 02 Oct 2025 03:17:19 GMT\"\n  ..$ strict-transport-security   : chr \"max-age=31536000\"\n  ..$ set-cookie                  : chr \"TS010383f0=01283c52a42aaec3c99ffaae1e428c9f519340c04eb846de1de64efe484537f6edd44eec88a2938d286c99dff2209b891140\"| __truncated__\n  ..$ transfer-encoding           : chr \"chunked\"\n  ..- attr(*, \"class\")= chr [1:2] \"insensitive\" \"list\"\n $ all_headers:List of 1\n  ..$ :List of 3\n  .. ..$ status : int 200\n  .. ..$ version: chr \"HTTP/1.1\"\n  .. ..$ headers:List of 12\n  .. .. ..$ cache-control               : chr \"max-age=60, must-revalidate\"\n  .. .. ..$ access-control-allow-origin : chr \"*\"\n  .. .. ..$ access-control-allow-methods: chr \"GET\"\n  .. .. ..$ access-control-allow-headers: chr \"Origin, X-Requested-With, Content-Type, Accept\"\n  .. .. ..$ referrer-policy             : chr \"same-origin\"\n  .. .. ..$ content-security-policy     : chr \"default-src 'self'; img-src 'self' data:; object-src 'none'; script-src 'self' 'unsafe-inline'; style-src 'self\"| __truncated__\n  .. .. ..$ x-content-type-options      : chr \"nosniff\"\n  .. .. ..$ content-type                : chr \"application/json;charset=utf-8\"\n  .. .. ..$ date                        : chr \"Thu, 02 Oct 2025 03:17:19 GMT\"\n  .. .. ..$ strict-transport-security   : chr \"max-age=31536000\"\n  .. .. ..$ set-cookie                  : chr \"TS010383f0=01283c52a42aaec3c99ffaae1e428c9f519340c04eb846de1de64efe484537f6edd44eec88a2938d286c99dff2209b891140\"| __truncated__\n  .. .. ..$ transfer-encoding           : chr \"chunked\"\n  .. .. ..- attr(*, \"class\")= chr [1:2] \"insensitive\" \"list\"\n $ cookies    :'data.frame':    1 obs. of  7 variables:\n  ..$ domain    : chr \"#HttpOnly_.api.census.gov\"\n  ..$ flag      : logi TRUE\n  ..$ path      : chr \"/\"\n  ..$ secure    : logi TRUE\n  ..$ expiration: POSIXct[1:1], format: \"Inf\"\n  ..$ name      : chr \"TS010383f0\"\n  ..$ value     : chr \"01283c52a42aaec3c99ffaae1e428c9f519340c04eb846de1de64efe484537f6edd44eec88a2938d286c99dff2209b891140f47ff5\"\n $ content    : raw [1:937508] 5b 5b 22 53 ...\n $ date       : POSIXct[1:1], format: \"2025-10-02 03:17:19\"\n $ times      : Named num [1:6] 0 0.00517 0.04478 0.11779 0.35402 ...\n  ..- attr(*, \"names\")= chr [1:6] \"redirect\" \"namelookup\" \"connect\" \"pretransfer\" ...\n $ request    :List of 7\n  ..$ method    : chr \"GET\"\n  ..$ url       : chr \"https://api.census.gov/data/2022/acs/acs1/pums?get=SEX,PWGTP,MAR&SCHL=24\"\n  ..$ headers   : Named chr \"application/json, text/xml, application/xml, */*\"\n  .. ..- attr(*, \"names\")= chr \"Accept\"\n  ..$ fields    : NULL\n  ..$ options   :List of 2\n  .. ..$ useragent: chr \"libcurl/8.14.1 r-curl/6.4.0 httr/1.4.7\"\n  .. ..$ httpget  : logi TRUE\n  ..$ auth_token: NULL\n  ..$ output    : list()\n  .. ..- attr(*, \"class\")= chr [1:2] \"write_memory\" \"write_function\"\n  ..- attr(*, \"class\")= chr \"request\"\n $ handle     :Class 'curl_handle' &lt;externalptr&gt; \n - attr(*, \"class\")= chr \"response\"\n\n\nThe raw output from httr::GET() is not immediately usable because it comes as JSON text with column names embedded in the first row. To fix this, we wrote a helper function called clean_census(). This function extracts the column names, removes the header row, and returns the result as a tibble. Because it is written generally, it can be reused for any Census API response.\n\nclean_query_result &lt;- function(res) {\n  pums_parsed &lt;- fromJSON(rawToChar(res$content))\n  colnames(pums_parsed) &lt;- pums_parsed[1,]\n  pums_info &lt;- as_tibble(pums_parsed[-1,])\n  return(pums_info)\n}\n\nThis code chunk creates some look up tables that will be useful for turning numeric variables into time values later in the pums_query() function.\n\n# Query the API for a table describing the JWAP and JWDP categorical variables and then create lookup tables to turn numeric variables into time variables later\n\njwap_url &lt;- \"https://api.census.gov/data/2022/acs/acs1/pums/variables/JWAP.json\"\njwap_blob &lt;- fromJSON(jwap_url)\njwap_lookup &lt;- jwap_blob$values$item\nnames(jwap_lookup) &lt;- as.numeric(names(jwap_lookup))\n\njwdp_url &lt;- \"https://api.census.gov/data/2022/acs/acs1/pums/variables/JWDP.json\"\njwdp_blob &lt;- fromJSON(jwdp_url)\njwdp_lookup &lt;- jwdp_blob$values$item\nnames(jwdp_lookup) &lt;- as.numeric(names(jwdp_lookup))\n\nThis code chunk creates some lists that will be useful for turning categorical variables into factors with appropriate levels later in the pums_query() function.\n\n# Save categorical variables as lists to turn into a factor with appropriate levels later\n\nFER_labels &lt;- c(\"0\" = \"N/A (less than 15 years/greater than 50 years/ male)\", \"1\" = \"Yes\", \"2\" = \"No\")\n\nHHL_labels &lt;- c(\"0\" = \"N/A (GQ/vacant)\", \"1\" = \"English Only\", \"2\" = \"Spanish\", \"3\" = \"Other Indo-European languages\", \"4\" = \"Asian and Pacific Island languages\", \"5\" = \"Other Language\")\n\nHISPEED_labels &lt;- c(\"0\" = \"N/A (GQ/vacant/no paid access to the internet)\", \"1\" = \"Yes\", \"2\" = \"No\")\n\nJWTRNS_labels &lt;- c(\"0\" = \"N/A (not a worker-not in the labor force, including persons under 16 years; unemployed; employed, with a job but not at work; Armed Forces, with a job but not at work)\", \"1\" = \"Car, truck, or van\", \"2\" = \"Bus\", \"3\" = \"Subway or elevated rail\", \"4\" = \"Long-distance train or commuter rail\", \"5\" = \"Light rail, streetcar, or trolley\", \"6\" = \"Ferryboat\", \"7\" = \"Taxicab\", \"8\" = \"Motorcycle\", \"9\" = \"Bicycle\", \"10\" = \"Walked\", \"11\" = \"Worked from home\", \"12\" = \"Other method\")\n\nSCH_labels &lt;- c(\"0\" = \"N/A (less than 3 years old)\", \"1\" = \"No, has not attended in the last 3 months\", \"2\" = \"Yes, public school or public college\", \"3\" = \"Yes, private school or college or home school\")\n\nSCHL_labels &lt;- c(\"0\" = \"N/A (less than 3 years old)\", \"1\" = \"No schooling completed\", \"2\" = \"Nursery school, preschool\", \"3\" = \"Kindergarten\", \"4\" = \"Grade 1\", \"5\" = \"Grade 2\", \"6\" = \"Grade 3\", \"7\" = \"Grade 4\", \"8\" = \"Grade 5\", \"9\" = \"Grade 6\", \"10\" = \"Grade 7\", \"11\" = \"Grade 8\", \"12\" = \"Grade 9\", \"13\" = \"Grade 10\", \"14\" = \"Grade 11\", \"15\" = \"12th grade - no diploma\", \"16\" = \"Regular high school diploma\", \"17\" = \"GED or alternative credential\", \"18\" = \"Some college, but less than 1 year\", \"19\" = \"1 or more years of college credit, no degree\", \"20\" = \"Associate's degree\", \"21\" = \"Bachelor's degree\", \"22\" = \"Master's degree\", \"23\" = \"Professional degree beyond a bachelor's degree\", \"24\" = \"Doctorate degree\")\n\nSEX_labels &lt;- c(\"1\" = \"Male\", \"2\" = \"Female\")\n\nNext, we need a function that can query the API while allowing the user to specify which data they would like to display. To do this, we wrote a function, pums_query() that allows users to specify the survey year, numeric variables, categorical variables, geography level, and optional data subsetting. Pums_query() performs type conversions which are necessary for some numeric and categorical variables. We also used checks to ensure that the inputs are valid, which helps to avoid API errors.\n\n# Query the API; we used state code 37 because 03 was invalid\npums_query &lt;- function(year = 2022, numeric_variables = c(\"AGEP\", \"PWGTP\"), categorical_variables = c(\"SEX\"), geography = \"state\", geography_code = \"37\"){\n  \n# Argument error checking\n  if(!(year %in% 2010:2022)){\n    stop(\"Year is not valid\")\n  }\n  if(!(\"PWGTP\" %in% numeric_variables)){\n    stop(\"PWGTP must be in numeric_variables\")\n  }\n  if(length(numeric_variables) &lt; 2){\n    stop(\"Another numeric variable must be requested\")\n  }\n  if(length(categorical_variables) &lt; 1){\n    stop(\"A categorical variable must be requested\")\n  }\n  if(!(tolower(geography) %in% c(\"all\", \"region\", \"division\", \"state\"))){\n    stop(\"Must specify geography level\")\n  }\n  if(geography == \"state\" && (!(geography_code %in% sprintf(\"%02d\", 1:72)) && geography_code != \"*\")){\n    stop(\"Geography_code for state must be 2 digit code between 01 and 72 or = * for all states\")\n  }\n  if(geography == \"region\" && (!(geography_code %in% sprintf(\"%01d\", 1:4)) && geography_code != \"*\")){\n    stop(\"Geography_code for region must be code between 1 and 4 or = * for all regions\")\n  }\n  if(geography == \"division\" && (!(geography_code %in% sprintf(\"%01d\", 1:9)) && geography_code != \"*\")){\n    stop(\"Geography_code for division must be code between 1 and 9 or = * for all divisions\")\n  }\n  \n# Combine variables into a comma separated string\n  variables &lt;- paste(c(numeric_variables, categorical_variables), collapse = \",\")\n  \n# Create the geography part of the query, allowing for subsetting. This code allows for user to call \"all\" geography by not including geography key from the URL if \"all\" is called.\n  geography_key &lt;- \"\"\n  if (geography != \"all\"){\n    geography_key &lt;- paste0(\"&for=\", geography,\":\", geography_code)\n  }\n  \n# Build the URL from the provided arguments\n  build_url &lt;- paste0(\"https://api.census.gov/data/\", year, \"/acs/acs1/pums?get=\", variables, geography_key)\n  \n# Send http GET request\n  url_result &lt;- httr::GET(build_url)\n  if(status_code(url_result) != 200){\n    stop(\"Request failed with status: \", status_code(url_result))\n  }\n  \n# Use helper function to turn url_result into a tibble\n  census_tibble &lt;- clean_query_result(url_result)\n  \n# Turn numeric variables into numeric values\n  numeric_options &lt;- c(\"AGEP\", \"GASP\", \"GRPIP\", \"PWGTP\", \"JWMNP\")\n  numeric_values &lt;- intersect(numeric_options, numeric_variables)\n  census_tibble[numeric_values] &lt;- lapply(census_tibble[numeric_values], as.numeric)\n  \n# Helper function which converts a given time range string into a time string which is the midpoint of the range\n  time_convert &lt;- function(time_range){\n    if (startsWith(time_range, \"N\")) return(NA)\n    times &lt;- strsplit(time_range, \" to \")[[1]]\n    start_time &lt;- period_to_seconds(hm(times[1]))\n    end_time &lt;- period_to_seconds(hm(times[2]))\n    if (end_time &lt; start_time) end_time &lt;- end_time + 24*3600\n    seconds &lt;- (start_time + end_time) / 2\n    time &lt;- as.POSIXct(seconds, origin = \"1970-01-01\", tz = \"UTC\")\n    return(format(time, \"%H:%M:%S %p\"))\n  }\n# Convert all values in JWAP and JWDP into time\n  if (\"JWAP\" %in% names(census_tibble)){\n    census_tibble[[\"JWAP\"]] &lt;- sapply(census_tibble[[\"JWAP\"]], function(x) time_convert(jwap_lookup[[x]]))\n  }\n  if (\"JWDP\" %in% names(census_tibble)){\n    census_tibble[[\"JWDP\"]] &lt;- sapply(census_tibble[[\"JWDP\"]], function(x) time_convert(jwdp_lookup[[x]]))\n  }\n# Convert categorical variable into a factor with appropriate levels \n  if (\"FER\" %in% names(census_tibble)){\n    census_tibble[[\"FER\"]] &lt;- factor(census_tibble[[\"FER\"]], levels = names(FER_labels), labels = FER_labels)\n  }\n  if (\"HHL\" %in% names(census_tibble)){\n    census_tibble[[\"HHL\"]] &lt;- factor(census_tibble[[\"HHL\"]], levels = names(HHL_labels), labels = HHL_labels)\n  }\n  if (\"HISPEED\" %in% names(census_tibble)){\n    census_tibble[[\"HISPEED\"]] &lt;- factor(census_tibble[[\"HISPEED\"]], levels = names(HISPEED_labels), labels = HISPEED_labels)\n  }\n  if (\"JWTRNS\" %in% names(census_tibble)){\n    census_tibble[[\"JWTRNS\"]] &lt;- factor(census_tibble[[\"JWTRNS\"]], levels = names(JWTRNS_labels), labels = JWTRNS_labels)\n  }\n  if (\"SCH\" %in% names(census_tibble)){\n    census_tibble[[\"SCH\"]] &lt;- factor(census_tibble[[\"SCH\"]], levels = names(SCH_labels), labels = SCH_labels)\n  }\n  if (\"SCHL\" %in% names(census_tibble)){\n    census_tibble[[\"SCHL\"]] &lt;- factor(census_tibble[[\"SCHL\"]], levels = names(SCHL_labels), labels = SCHL_labels)\n  }\n  if (\"SEX\" %in% names(census_tibble)){\n    census_tibble[[\"SEX\"]] &lt;- factor(census_tibble[[\"SEX\"]], levels = names(SEX_labels), labels = SEX_labels)\n  }\n  \n# Add census class to census_tibble\n  class(census_tibble) &lt;- c(\"census\", class(census_tibble))\n  \n  return(census_tibble)\n}\n\nNow, we can test our function by requesting data for a single year with numeric variables, categorical variables, and geography.\n\nsample_data &lt;- pums_query(\n  year = 2022, numeric_variables = c(\"AGEP\", \"PWGTP\", \"GASP\", \"GRPIP\", \"JWAP\", \"JWDP\", \"JWMNP\"), categorical_variables = c(\"SEX\", \"FER\", \"HHL\", \"HISPEED\", \"JWTRNS\", \"SCH\", \"SCHL\"), geography = \"state\", geography_code = \"37\"\n)\nhead(sample_data)\n\n# A tibble: 6 × 15\n   AGEP PWGTP  GASP GRPIP JWAP      JWDP  JWMNP SEX   FER   HHL   HISPEED JWTRNS\n  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt; &lt;dbl&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt;   &lt;fct&gt; \n1    80    45     3     0 &lt;NA&gt;      &lt;NA&gt;      0 Male  N/A … N/A … N/A (G… N/A (…\n2    60     7     3     0 &lt;NA&gt;      &lt;NA&gt;      0 Male  N/A … N/A … N/A (G… N/A (…\n3    18    64     3     0 08:07:00… 08:0…     5 Male  N/A … N/A … N/A (G… Walked\n4    18    56     3     0 &lt;NA&gt;      &lt;NA&gt;      0 Male  N/A … N/A … N/A (G… N/A (…\n5    87    50     3     0 &lt;NA&gt;      &lt;NA&gt;      0 Fema… N/A … N/A … N/A (G… N/A (…\n6    18    56     3     0 &lt;NA&gt;      &lt;NA&gt;      0 Male  N/A … N/A … N/A (G… N/A (…\n# ℹ 3 more variables: SCH &lt;fct&gt;, SCHL &lt;fct&gt;, state &lt;chr&gt;\n\n\nThe last function was able to return a tibble for a single year of data, so now we need to expand on this to call data from multiple years. Pums_multi_year() loops over each requested year, calls pums_query() for each, and combines the results into a single tibble with a year column. This allows for comparison across years.\n\n# Create a function that calls the single year function as many times as needed and combines into one final tibble\npums_multi_year &lt;- function(years, numeric_variables = c(\"AGEP\", \"PWGTP\"), categorical_variables = c(\"SEX\"), geography = \"state\", geography_code = \"37\"){\n  years &lt;- as.integer(years)\n  all_data &lt;- list()\n# Call single year query function once for each year\n  for(yr in years){\n    test_tibble &lt;- pums_query(\n      year = yr, numeric_variables = numeric_variables, categorical_variables = categorical_variables, geography = geography, geography_code = geography_code\n    )\n# Add year column\n    test_tibble$year &lt;- yr\n\n    all_data[[as.character(yr)]] &lt;- test_tibble\n  }\n# Combines data from given years into one final tibble\n  combined_data &lt;-dplyr::bind_rows(all_data)\n  return(combined_data)\n}\n\nNow to test the multi-year function.\n\nsample_multi_year &lt;- pums_multi_year(\n  years = 2018:2019, numeric_variables = c(\"AGEP\", \"PWGTP\", \"GASP\", \"GRPIP\", \"JWAP\", \"JWDP\", \"JWMNP\"), categorical_variables = c(\"SEX\", \"FER\", \"HHL\", \"HISPEED\", \"SCH\", \"SCHL\"), geography = \"state\", geography_code = \"37\"\n)\nhead(sample_multi_year)\n\n# A tibble: 6 × 15\n   AGEP PWGTP  GASP GRPIP JWAP  JWDP  JWMNP SEX    FER       HHL   HISPEED SCH  \n  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;fct&gt;  &lt;fct&gt;     &lt;fct&gt; &lt;fct&gt;   &lt;fct&gt;\n1    37    11     3     0 &lt;NA&gt;  &lt;NA&gt;      0 Male   N/A (les… N/A … N/A (G… No, …\n2    90    21     3     0 &lt;NA&gt;  &lt;NA&gt;      0 Female N/A (les… N/A … N/A (G… No, …\n3    49     4     3     0 &lt;NA&gt;  &lt;NA&gt;      0 Male   N/A (les… N/A … N/A (G… No, …\n4    20    74     3     0 &lt;NA&gt;  &lt;NA&gt;      0 Male   N/A (les… N/A … N/A (G… Yes,…\n5    46     3     3     0 &lt;NA&gt;  &lt;NA&gt;      0 Male   N/A (les… N/A … N/A (G… No, …\n6    24    58     3     0 &lt;NA&gt;  &lt;NA&gt;      0 Male   N/A (les… N/A … N/A (G… No, …\n# ℹ 3 more variables: SCHL &lt;fct&gt;, state &lt;chr&gt;, year &lt;int&gt;\n\n\nAt this point, we have developed a set of functions that can query the API, return tibbles, and combine data across years. In the next section we will build generic summarizing and plotting functions to explore the data in more detail.\n\n\nWriting a Generic Function for Summarizing\nHere we write a general function for summarizing. This function takes in three arguments: the tibble with class census, the numeric variable(s) to summarize, and the categorical variable(s) to summarize. By default, this function summarizes all numeric variables (other than PWGTP) and all categorical variables in the tibble. However, the user may also specify the variables they’d like to summarize. For numerical variables, the function will give the sample mean and standard deviation, and for categorical variables the function returns the counts. Here we also write a general function for plotting, where the user can specify one categorical variable and one numeric variable for plotting purposes.\n\n# Check structure of tibble\nstr(sample_data)\n\ncensus [109,230 × 15] (S3: census/tbl_df/tbl/data.frame)\n $ AGEP   : num [1:109230] 80 60 18 18 87 18 39 40 21 19 ...\n $ PWGTP  : num [1:109230] 45 7 64 56 50 56 36 38 38 8 ...\n $ GASP   : num [1:109230] 3 3 3 3 3 3 3 3 3 3 ...\n $ GRPIP  : num [1:109230] 0 0 0 0 0 0 0 0 0 0 ...\n $ JWAP   : Named chr [1:109230] NA NA \"08:07:00 AM\" NA ...\n  ..- attr(*, \"names\")= chr [1:109230] \"0\" \"0\" \"95\" \"0\" ...\n $ JWDP   : Named chr [1:109230] NA NA \"08:02:00 AM\" NA ...\n  ..- attr(*, \"names\")= chr [1:109230] \"0\" \"0\" \"55\" \"0\" ...\n $ JWMNP  : num [1:109230] 0 0 5 0 0 0 0 0 5 0 ...\n $ SEX    : Factor w/ 2 levels \"Male\",\"Female\": 1 1 1 1 2 1 1 1 1 2 ...\n $ FER    : Factor w/ 3 levels \"N/A (less than 15 years/greater than 50 years/ male)\",..: 1 1 1 1 1 1 1 1 1 3 ...\n $ HHL    : Factor w/ 6 levels \"N/A (GQ/vacant)\",..: 1 1 1 1 1 1 1 1 1 1 ...\n $ HISPEED: Factor w/ 3 levels \"N/A (GQ/vacant/no paid access to the internet)\",..: 1 1 1 1 1 1 1 1 1 1 ...\n $ JWTRNS : Factor w/ 13 levels \"N/A (not a worker-not in the labor force, including persons under 16 years; unemployed; employed, with a job bu\"| __truncated__,..: 1 1 11 1 1 1 1 1 2 12 ...\n $ SCH    : Factor w/ 4 levels \"N/A (less than 3 years old)\",..: 2 2 2 3 2 3 2 2 2 4 ...\n $ SCHL   : Factor w/ 25 levels \"N/A (less than 3 years old)\",..: 11 19 17 19 17 19 17 16 17 21 ...\n $ state  : chr [1:109230] \"37\" \"37\" \"37\" \"37\" ...\n\n# Function takes in tibble, numeric variables, categorical variables\nsummary_census &lt;- function(census, numeric_var=NULL, cat_var=NULL){\n  \n# Naming all possible categorical variables\ncat_vars &lt;- c(\"SEX\", \"FER\", \"HHL\", \"HISPEED\", \"SCH\", \"SCHL\")\n\n# Naming all possible categorical variables for this function \nall_cat_vars&lt;-intersect(cat_vars, names(census))\n\n# Naming all possible numerical variables for the funciton\nnum_vars &lt;- c(\"AGEP\", \"PWGTP\", \"GASP\", \"GRPIP\", \"JWMNP\")\n\n# Naming all possible numerica variables for this function \nall_num_vars&lt;-intersect(num_vars, names(census))\n  \n# Assigning weight to the column PWGTP in the data\n  weight &lt;- census$PWGTP\n# This first if() will give back everything by default if no numeric or categorical variables are entered\n  if (is.null(numeric_var) & is.null(cat_var)) {\n   numeric_cols &lt;- names(census)[sapply(census, is.numeric)]\n\nsummary &lt;- census |&gt;\n  reframe(\n    # Sample mean\n    across(\n       all_of(all_num_vars[all_num_vars != \"PWGTP\"]),\n      function(x) sum(x * weight, na.rm = TRUE) / sum(weight, na.rm = TRUE),\n      .names = \"{.col}_sample_mean\"\n    ),\n    # Sample standard deviation\n    across(\n       all_of(all_num_vars[all_num_vars != \"PWGTP\"]),\n      function(x) sqrt(sum((x)^2 * weight, na.rm = TRUE) / sum(weight, na.rm = TRUE) -\n         (sum(x * weight, na.rm = TRUE) / sum(weight, na.rm = TRUE))^2),\n      .names = \"{.col}_sample_sd\"\n    )\n  )\n\n# Here we count the categorical variables\n   cat_counts &lt;- census |&gt;\n      as.data.frame() |&gt;\n     select(all_cat_vars, PWGTP) |&gt;\n  pivot_longer(\n    cols = all_cat_vars,\n    names_to = \"variable\",\n    values_to = \"value\"\n  ) |&gt;\n      group_by(variable, value) |&gt;\n      summarise(weighted_count = sum(PWGTP), .groups = \"drop\")\n   \n# Here we return the numerical and categorical summaries\nreturn(list(\n  Numeric_Summary = summary,\n  Categorical_Counts = cat_counts\n))\n   \n# This handles if the user does not submit any numeric variables, only categorical. It will provide the counts for the categorical variables they provided \n  } else if (is.null(numeric_var)) { \n   cat_counts &lt;- census |&gt;\n     select(all_cat_vars, PWGTP) |&gt;\n      pivot_longer(\n       cols = all_of(cat_var),\n        names_to = \"variable\",\n        values_to = \"value\"\n      ) |&gt;\n      group_by(variable, value) |&gt;\n      summarise(weighted_count = sum(PWGTP), .groups = \"drop\")\n   \n   return(\n  Categorical_Counts = cat_counts\n)\n\n# This handles if the user does not submit any categorical variables, only numerical It will provide the summaries for the numerical variables they provided \n  } else if(is.null(cat_var)) {\n  \n# Now we need to find the sample mean and standard deviation for the numerical variables they provided\n    summary &lt;- census |&gt;\n  reframe(\n    # Sample mean\n    across(\n      all_of(numeric_var),\n      function(x) sum(x * weight / sum(weight)),\n      .names = \"{.col}_sample_mean\"\n    ),\n    # Sample standard deviation\n    across(\n      all_of(numeric_var),\n      function(x) sqrt(sum(x^2 * weight) / sum(weight) - (sum(x * weight / sum(weight)))^2),\n      .names = \"{.col}_sample_sd\"\n    )\n  )\nreturn(list(\n  Numeric_Summary = summary\n))\n\n# This handles if the user enters categorical and numeric variables\n  }else{\n      cat_counts &lt;- census |&gt;\n     select(all_cat_vars, PWGTP) |&gt;\n      pivot_longer(\n       cols = all_of(cat_var),\n        names_to = \"variable\",\n        values_to = \"value\"\n      ) |&gt;\n      group_by(variable, value) |&gt;\n      summarise(weighted_count = sum(PWGTP), .groups = \"drop\")\n   \n      \n# Now we need to find the sample mean and standard deviation for the numerical variables they provided\n    summary &lt;- census |&gt;\n      as.data.frame()|&gt;\n  reframe(\n    # Sample mean\n    across(\n      all_of(all_num_vars[all_num_vars != \"PWGTP\"]),\n      function(x) sum(x * weight / sum(weight)),\n      .names = \"{.col}_sample_mean\"\n    ),\n    # Sample standard deviation\n    across(\n      all_of(all_num_vars[all_num_vars != \"PWGTP\"]),\n      function(x) sqrt(sum(x^2 * weight) / sum(weight) - (sum(x * weight / sum(weight)))^2),\n      .names = \"{.col}_sample_sd\"\n    )\n  )\nreturn(list(\n  Numeric_Summary = summary,\n  Categorical_Counts = cat_counts\n))\n  }\n} \n# Test of just entering tibble\nsummary_census(sample_data)\n\nWarning: Using an external vector in selections was deprecated in tidyselect 1.1.0.\nℹ Please use `all_of()` or `any_of()` instead.\n  # Was:\n  data %&gt;% select(all_cat_vars)\n\n  # Now:\n  data %&gt;% select(all_of(all_cat_vars))\n\nSee &lt;https://tidyselect.r-lib.org/reference/faq-external-vector.html&gt;.\n\n\n$Numeric_Summary\n# A tibble: 1 × 8\n  AGEP_sample_mean GASP_sample_mean GRPIP_sample_mean JWMNP_sample_mean\n             &lt;dbl&gt;            &lt;dbl&gt;             &lt;dbl&gt;             &lt;dbl&gt;\n1             39.6             49.5              9.64              10.0\n# ℹ 4 more variables: AGEP_sample_sd &lt;dbl&gt;, GASP_sample_sd &lt;dbl&gt;,\n#   GRPIP_sample_sd &lt;dbl&gt;, JWMNP_sample_sd &lt;dbl&gt;\n\n$Categorical_Counts\n# A tibble: 43 × 3\n   variable value                                                weighted_count\n   &lt;chr&gt;    &lt;fct&gt;                                                         &lt;dbl&gt;\n 1 FER      N/A (less than 15 years/greater than 50 years/ male)        8179426\n 2 FER      Yes                                                          127864\n 3 FER      No                                                          2391683\n 4 HHL      N/A (GQ/vacant)                                              281244\n 5 HHL      English Only                                                8636010\n 6 HHL      Spanish                                                     1075744\n 7 HHL      Other Indo-European languages                                326612\n 8 HHL      Asian and Pacific Island languages                           260114\n 9 HHL      Other Language                                               119249\n10 HISPEED  Yes                                                         8316849\n# ℹ 33 more rows\n\n# Test of entering tibble with numeric variable\nsummary_census(sample_data, numeric_var = \"AGEP\")\n\n$Numeric_Summary\n# A tibble: 1 × 2\n  AGEP_sample_mean AGEP_sample_sd\n             &lt;dbl&gt;          &lt;dbl&gt;\n1             39.6           23.2\n\n# Test of entering tibble with categorical variable\nsummary_census(sample_data, cat_var = \"SEX\")\n\n# A tibble: 2 × 3\n  variable value  weighted_count\n  &lt;chr&gt;    &lt;fct&gt;           &lt;dbl&gt;\n1 SEX      Male          5228672\n2 SEX      Female        5470301\n\n# Test of entering tibble with categorical variable\nsummary_census(sample_data, numeric_var = \"AGEP\", cat_var = \"SEX\")\n\n$Numeric_Summary\n  AGEP_sample_mean GASP_sample_mean GRPIP_sample_mean JWMNP_sample_mean\n1         39.63556         49.52083          9.638434          10.01047\n  AGEP_sample_sd GASP_sample_sd GRPIP_sample_sd JWMNP_sample_sd\n1       23.18036       127.0942        20.87654        18.07373\n\n$Categorical_Counts\n# A tibble: 2 × 3\n  variable value  weighted_count\n  &lt;chr&gt;    &lt;fct&gt;           &lt;dbl&gt;\n1 SEX      Male          5228672\n2 SEX      Female        5470301\n\n# Test of entering tibble with more than one numerical variable\nsummary_census(sample_data, numeric_var = c(\"AGEP\", \"GASP\"))\n\n$Numeric_Summary\n# A tibble: 1 × 4\n  AGEP_sample_mean GASP_sample_mean AGEP_sample_sd GASP_sample_sd\n             &lt;dbl&gt;            &lt;dbl&gt;          &lt;dbl&gt;          &lt;dbl&gt;\n1             39.6             49.5           23.2           127.\n\n# Test of entering tibble with more than one categorical variable\nsummary_census(sample_data, cat_var = c(\"SEX\", \"SCHL\"))\n\n# A tibble: 27 × 3\n   variable value                       weighted_count\n   &lt;chr&gt;    &lt;fct&gt;                                &lt;dbl&gt;\n 1 SCHL     N/A (less than 3 years old)         333805\n 2 SCHL     No schooling completed              359428\n 3 SCHL     Nursery school, preschool           151144\n 4 SCHL     Kindergarten                        124318\n 5 SCHL     Grade 1                             118561\n 6 SCHL     Grade 2                             134499\n 7 SCHL     Grade 3                             144116\n 8 SCHL     Grade 4                             142466\n 9 SCHL     Grade 5                             154565\n10 SCHL     Grade 6                             166475\n# ℹ 17 more rows\n\n# Test of entering tibble with more than one categorical variable and more than one numeric variable\nsummary_census(sample_data, numeric_var = c(\"GRPIP\", \"JWMNP\"), cat_var = c(\"HHL\", \"HISPEED\"))\n\n$Numeric_Summary\n  AGEP_sample_mean GASP_sample_mean GRPIP_sample_mean JWMNP_sample_mean\n1         39.63556         49.52083          9.638434          10.01047\n  AGEP_sample_sd GASP_sample_sd GRPIP_sample_sd JWMNP_sample_sd\n1       23.18036       127.0942        20.87654        18.07373\n\n$Categorical_Counts\n# A tibble: 9 × 3\n  variable value                                          weighted_count\n  &lt;chr&gt;    &lt;fct&gt;                                                   &lt;dbl&gt;\n1 HHL      N/A (GQ/vacant)                                        281244\n2 HHL      English Only                                          8636010\n3 HHL      Spanish                                               1075744\n4 HHL      Other Indo-European languages                          326612\n5 HHL      Asian and Pacific Island languages                     260114\n6 HHL      Other Language                                         119249\n7 HISPEED  N/A (GQ/vacant/no paid access to the internet)        1009892\n8 HISPEED  Yes                                                   8316849\n9 HISPEED  No                                                    1372232\n\n\n\n\nPlotting\nHere we write a general function for plotting, where the user can specify one categorical variable and one numeric variable for plotting purposes.\n\n# Run these in your console\nplot.function #what is used for a class = function\n\nfunction (x, y = 0, to = 1, from = y, xlim = NULL, ylab = NULL, \n    ...) \n{\n    if (!missing(y) && missing(from)) \n        from &lt;- y\n    if (is.null(xlim)) {\n        if (is.null(from)) \n            from &lt;- 0\n    }\n    else {\n        if (missing(from)) \n            from &lt;- xlim[1L]\n        if (missing(to)) \n            to &lt;- xlim[2L]\n    }\n    if (is.null(ylab)) {\n        sx &lt;- substitute(x)\n        ylab &lt;- if (mode(x) != \"name\") \n            deparse(sx)[1L]\n        else {\n            xname &lt;- list(...)[[\"xname\"]]\n            if (is.null(xname)) \n                xname &lt;- \"x\"\n            paste0(sx, \"(\", xname, \")\")\n        }\n    }\n    curve(expr = x, from = from, to = to, xlim = xlim, ylab = ylab, \n        ...)\n}\n&lt;bytecode: 0x1064ffca8&gt;\n&lt;environment: namespace:graphics&gt;\n\ngetS3method(\"plot\",\"data.frame\") #what is used for a class = data frame\n\nfunction (x, ...) \n{\n    plot2 &lt;- function(x, xlab = names(x)[1L], ylab = names(x)[2L], \n        ...) plot(x[[1L]], x[[2L]], xlab = xlab, ylab = ylab, \n        ...)\n    if (!is.data.frame(x)) \n        stop(\"'plot.data.frame' applied to non data frame\")\n    if (ncol(x) == 1) {\n        x1 &lt;- x[[1L]]\n        if (class(x1)[1L] %in% c(\"integer\", \"numeric\")) \n            stripchart(x1, ...)\n        else plot(x1, ...)\n    }\n    else if (ncol(x) == 2) {\n        plot2(x, ...)\n    }\n    else {\n        pairs(data.matrix(x), ...)\n    }\n}\n&lt;bytecode: 0x10648d668&gt;\n&lt;environment: namespace:graphics&gt;\n\nplot\n\nfunction (x, y, ...) \nUseMethod(\"plot\")\n&lt;bytecode: 0x116031318&gt;\n&lt;environment: namespace:base&gt;\n\ncensus_plot &lt;-function(census_data, cat_var, num_var){\nggplot(census_data,\naes(x = cat_var, y = num_var, weight = PWGTP)) +\ngeom_boxplot()\n}\n\n# Test of plot function\ncensus_plot(sample_data, cat_var = \"SEX\", num_var = \"AGEP\")\n\n\n\n\n\n\n\n\n\n\nData Investigation\nNow, we will investigate whether there is a relationship between household internet access and age in North Carolina in 2022. Specifically, we are asking the following: are younger people more likely to live in households with high-speed internet access?\nTo do this, we will query the Census PUMS API for 2022 North Carolina data, selecting age (AGE) as the numeric variable and household high-speed internet access (HISPEED) as the categorical variable. We then summarize the data and generate a boxplot to visualize the relationship between the variables.\n\n# Query the API\nnc_data &lt;- pums_query(year = 2022, numeric_variables = c(\"AGEP\", \"PWGTP\"), categorical_variables = \"HISPEED\", geography = \"state\", geography_code = \"37\")\n\n# Summarize\nsummary_census(nc_data, numeric_var = \"AGEP\", cat_var =\"HISPEED\")\n\n$Numeric_Summary\n  AGEP_sample_mean AGEP_sample_sd\n1         39.63556       23.18036\n\n$Categorical_Counts\n# A tibble: 3 × 3\n  variable value                                          weighted_count\n  &lt;chr&gt;    &lt;fct&gt;                                                   &lt;dbl&gt;\n1 HISPEED  N/A (GQ/vacant/no paid access to the internet)        1009892\n2 HISPEED  Yes                                                   8316849\n3 HISPEED  No                                                    1372232\n\n# Plot of the variables\ncensus_plot(nc_data, cat_var = \"HISPEED\", num_var = \"AGEP\")\n\n\n\n\n\n\n\n\nThe graph shows that the median age of individuals living in households with high-speed internet access appears lower than the median age of those in households without high speed access or N/A with no paid access to the internet. This suggests that younger people may be more likely to reside in households with internet access, though further statistical analysis would be needed to confirm this relationship."
  }
]